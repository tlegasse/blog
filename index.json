[{"content":" Testing\nIntroduction Main Content Conclusion References ","permalink":"https://www.tannerlegasse.com/posts/testing/","summary":"test description","title":"Testing"},{"content":"Introduction Powder toy (also known as a falling sand game), for those not familiar, is an sandbox like simulation game where the user is generally free to experiment with various materials which can interact together or sometimes on their own. Some of the game-play mechanics have found their way into public consciousness through games like Noita, a popular rogue-like game with realistic material interactions. As an example of how these games generally play, you can check out the video below.\nI remember running powder toy games back in middle school in MS-DOS, and was endlessly impressed with its smooth operation and engaging gameplay mechanics. Maybe there\u0026rsquo;s even an argument to make that it\u0026rsquo;s one of the quintessential games-with-no-end in the same way that Minecraft used to be. It\u0026rsquo;s just a toy! A powder toy!\nWhat is Powder Toy? Surprising, right? We already talked about this! Actually for the purposes of this article, let\u0026rsquo;s jump into the specific mechanics of the game, but first a bit about its lineage. Powder toy actually shares a lot of similar characteristics of an older game, Conway\u0026rsquo;s Game of Life (GOL). Both of these (and others like them) are cellular automata, cells are a determined state, and have rules that they abide by in interacting with their environment.\nA Cellular\u0026hellip; what? Now, this may sound complex, but the beauty of cellular automata is that it\u0026rsquo;s surprisingly simple, I promise you\u0026rsquo;ll get it. This is how Life works:\nThe world is represented by a 2 dimensional array of \u0026ldquo;cells\u0026rdquo;. The game world ticks forward one turn at a time. A cell is either alive or dead. A cell has neighbors. A cell comes to life if it has just the right amount of neighbors. A cell can\u0026rsquo;t do the life thing if it has too many neighbors, or too few neighbors. A ce\u0026hellip; wait\u0026hellip; that\u0026rsquo;s it. That\u0026rsquo;s all of the rules. Bonus: check out the GOL I whipped up while flying to New York. Just hit play üòÅ\nSee the Pen Tanner's game of life by Tanner Legasse (@tlegasse) on CodePen. Okay, so GOL is about as simple as you can get while still being interactive. There\u0026rsquo;s some more aspects to consider, and more fundamental mechanisms by which cellular environments can be simulated (Elementary Cellular Automaton), but for our purposes, we\u0026rsquo;re going to skip ahead. Spend some time digging if you want more good reading!\nWhat makes Powder Toy different? If you\u0026rsquo;re content with GOL, congrats, go back up and have fun. Some, however, want a more compelling and realistic experience, so the question becomes \u0026ldquo;what?\u0026rdquo; and \u0026ldquo;how?\u0026rdquo;. previously, the data structure was exceedingly simple. One set of rules apply to the only cell type in the game, and most of the cell\u0026rsquo;s data consists of the following (this is the constructor of my GOL Cell class):\nconstructor(x, y) { let isAlive = Math.floor(Math.random() * 2) this.x = x this.y = y this.alive = isAlive ... } As you can see, we just need to know X and Y, as well as the cell\u0026rsquo;s alive status. Everything else in the constructor is related to keeping that data up to date, but that\u0026rsquo;s it. If you had a cell that couldn\u0026rsquo;t die, couldn\u0026rsquo;t be interacted with and was always alive, you\u0026rsquo;d have a wall. A different material type, but very similar. If you had one type of cell that could interact with another cell that converted either/or to an area of high pressure and temperature, you\u0026rsquo;d have fire and gasoline. Those work differently, you could imagine gas being quickly taken over in a series of turns, and moving gradually away from high pressure zones. You could imagine the fire not going away, and responding to gravity; that\u0026rsquo;s stuff we usually call lava. What happens when you mix dirt, water and seeds? Plants!\nAt the end of the day/ experiment, the simplicity derived from cells interacting together represents a fun toy, and an even more enjoyable software writing experience.\nGoals I\u0026rsquo;m going to be recreating some of the functionality of powder toy using Go. It is in some ways a non-natural way to leverage Go\u0026rsquo;s robust strengths, however this project will be killing 2 birds with one stone. I\u0026rsquo;ll be leveraging Go\u0026rsquo;s ability to compile to WASM (WebAssembly), and some interesting tools to pull in and serve the build packages. It\u0026rsquo;ll be only as simple as it can be to serve its purpose, and I\u0026rsquo;ll be hosting the finished product, after a few follow up articles, right here, so stay tuned and let me know how you end up liking the process!\n","permalink":"https://www.tannerlegasse.com/projects/creating-powder-toy/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003ePowder toy (also known as a falling sand game), for those not familiar, is an sandbox like simulation game where the user is generally free to experiment with various materials which can interact together or sometimes on their own. Some of the game-play mechanics have found their way into public consciousness through games like \u003ca href=\"https://en.wikipedia.org/wiki/Noita_%28video_game%29\"\u003eNoita\u003c/a\u003e, a popular rogue-like game with realistic material interactions. As an example of how these games generally play, you can check out the video below.\u003c/p\u003e","title":"Creating Powder Toy"},{"content":"Introduction It\u0026rsquo;s 3AM. You need a URL shortener fast. Your boss is breathing down your neck and you have no idea what to do. My new URL shortener is exactly what you need. Okay, kidding aside, this thing isn\u0026rsquo;t geared toward production environments with high throughput or anything like that. Instead, the goal was to showcase skills that I\u0026rsquo;ve picked up over the past several months in my learning journey with Go. It\u0026rsquo;s been really fun, and this project fit the bill of \u0026ldquo;complex enough to be interesting, not so complex that you program yourself into a hole\u0026rdquo;. The latter will come shortly, but for now I\u0026rsquo;m really pleased with how everything\u0026rsquo;s come out.\nNote: This code is still evolving, it may change over the next several weeks\nFeatures The URL shortener only has 2 routes for now, one capturing GET requests for the shortening process, and a dynamic path for long-ening the path again. That\u0026rsquo;s it. Really. BUT there were so many amazing things that this project exposed me to. My previous Go projects were Leetcode problems, so I was missing on a lot of the project-level learnings.\nThings learned Implementing this functionality was a treat. It exposed me to some common patterns and enabled me to learn about the ins and outs, and infrastructure of Go projects. Check out some of my favorite discoveries below.\nTesting Unit testing admittedly isn\u0026rsquo;t every agency or company\u0026rsquo;s top priority, and I have had some ground to make up. Now, in every project I embark on, I aim to provide thoroughly tested code. In this case, I was exposed to database and HTTP server mocking, test fixtures and more. I found the workflow to be intuitive and very helpful in rounding out my chosen feature set.\nHTTP Server While the batteries included approach to the Golang standard library means that it comes with a competent and simple HTTP server, it wasn\u0026rsquo;t a mistake that I chose to work with it. I wanted to ensure that my plans of picking up API related tooling experience was in focus during this project.\nChallenges Embedding: This is the big one, and seems to fly under the radar in terms of what Go developers are exposed to first. But first, what problem will the embedding pattern solve? In short, when you\u0026rsquo;re running unit tests, the execution directory, and packages compiled into the binary are different than when you\u0026rsquo;re running your program normally. You might be able to leverage relative pathing fairly easily when your code is running from the top level directory. When you\u0026rsquo;re testing though\u0026hellip; ooh momma\u0026hellip; the filesystem context changes drastically. In the code below, you can see how I\u0026rsquo;m leveraging the embed package to compile the SQL statements needed to spin up my database table directly into the binary. Now, there are many approaches to solving this problem, and embedding files can definitely be a mistake, but in this case it was just what the doctor ordered.\nFirst, import the sucker.\nimport ( ... \u0026#34;embed\u0026#34; ... ) Using the go:embed directive, we then specify a pattern to match to the local filesystem, and initialize a variable with the\n//go:embed schema.sql var schemaFS embed.FS And then we can use the embedded file just like we would with a normal file!\ncontent, err := schemaFS.ReadFile(\u0026#34;schema.sql\u0026#34;) Understanding the data flow I will admit, dependency injection is an extremely important software design pattern as it allows for a the kind of modularity that makes huge successful projects a possibility, but it can cause issues if you\u0026rsquo;re a beginner exploring new programming languages. In this case, it was a difference between technologies I\u0026rsquo;m used to programming in (JavaScript), and Go. What could that be? Call by value.\nYes, this is a n00b issue, and was the result of storing data in structs within packages, and it tripped me up relentlessly. There would be issues where my database mock wasn\u0026rsquo;t being referenced and called for pattern matching, or data wasn\u0026rsquo;t flowing the way I expected, but I got through it. In hindsight, this one seems pretty silly, bit I\u0026rsquo;m genuinely glad that it came up so prevalantly in this project, because this is just one of those things you need to develop a sort of muscle memory for.\nTechnologies Used Viper: Parses a wide range of configuration file formats. Sqlite3 driver: Helped me drive the database. Go-Sqlmock: My favorite new package. I was genuinely surprised with how intuitive and fun the workflow with go-sqlmock was, seriously! You get to spin up a mock SQL driver, pass it to a function or declare a variable with it, and it pattern matches requests, returning pre-defined results. Conclusions I encourage you to go check out the code, because it was a lot of fun to write. This project was primarily focused on the how\u0026rsquo;s, why\u0026rsquo;s, and the most basic of basics, but the next project may (or may not!) have more real world applications, so stay tuned for more üòâ\n","permalink":"https://www.tannerlegasse.com/projects/go-url-shortener/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eIt\u0026rsquo;s 3AM. You need a URL shortener fast. Your boss is breathing down your neck and you have no idea what to do. My new URL shortener is \u003cem\u003eexactly\u003c/em\u003e what you need. Okay, kidding aside, this thing isn\u0026rsquo;t geared toward production environments with high throughput or anything like that. Instead, the goal was to showcase skills that I\u0026rsquo;ve picked up over the past several months in my learning journey with Go. It\u0026rsquo;s been really fun, and this project fit the bill of \u0026ldquo;complex enough to be interesting, not so complex that you program yourself into a hole\u0026rdquo;. The latter will come shortly, but for now I\u0026rsquo;m really pleased with how everything\u0026rsquo;s come out.\u003c/p\u003e","title":"Go URL Shortener"},{"content":"Introduction I\u0026rsquo;ve been an e-commerce developer for most of my career, and I\u0026rsquo;ve been using PHP and JS for most of that time. When I was cutting my teeth, I was developing Wordpress extensions and tweaking themes. Mundane work of course, but I was SO excited. I was finally tapping into a part of myself that I didn\u0026rsquo;t fully understand, my thirst for software development.\nFast forward 8 years, and here I am, still just as excited about software development as I was when I first started, but there are problems, and I\u0026rsquo;m not the same person I was back then. I\u0026rsquo;ve touched JS build systems, became a Shopify expert, programmed in Python, JS, Ruby and more, worked on frameworks and have built my own, but my interest in becoming the best ME that I can be is nagging at me to do something different. I want to connect the dots, empower the teams I work with by creating better environments for developers like me, and most importantly, I want to have the right tools to do so. Enter Go.\nWhy Go? Go has an incredible foothold in some of the most exciting and integral processes that businesses rely upon daily. DevOps tools like Docker and Kubernetes are written in Go, and in my journey so far there seems to be little doubt why. Go is fast, but most importantly succinct. Programming in Go thus far has made me feel like I know more about why they chose the name, it\u0026rsquo;s short, sweet and helps you get your code out of the door. Go is also effective, efficient and has powerful concurrency tools that make document.AddEventListener() feel\u0026hellip; off.\nHere\u0026rsquo;s an example. I worked for a client whose website communicated with a rental listings service, built and written in ancient PHP. Yeah, that kind, where you needed to knock the cobwebs off of the code before you could even read it, but somehow it felt more traveled than Everest and they didn\u0026rsquo;t have version control. The code was slow, and it was next to impossible to read, but it worked, and it worked well. Did you spot it? The \u0026ldquo;impossible to read\u0026rdquo; part? That had real business implications, including bugs being introduced with every new feature becoming a fact of life, and with a precedence set from those that came before that similar features should begin with a copy and a paste.\nI might have an unpopular opinion here, but I feel that the monolithic architecture that they owned was already hurting them when we started, and at the end of the day, this part of the system was just creating lines in a database. Rather than using a Drupal module to communicate with the service, we could have used a Go service to do the same thing, and it would have been faster, more reliable and easier to maintain. It could be an instance where you set up a new cron job and send requests to another virtual host on the LAMP stack that shared the database, but even then it may be necessary to implement or vendorize an Object Relationship Mapping (ORM) to handle the data. And by the way, another issue with this system, there were no concurrent requests. Imports would take actual hours.\nLet\u0026rsquo;s review the benefits of using Go in this situation:\nA built-in package manager, rather than installing composer (another dependency) and then installing the package. Built-in concurrency support, meaning that we can have multiple requests running at once, and limiting where needed (out of the box). A highly readable and simplistic syntax, meaning that we can easily read and understand the code, and it\u0026rsquo;s easier to maintain. It would be decoupled from the website code. Best of all, the compiler analyzes the code and tells you where you\u0026rsquo;ve made mistakes, and it won\u0026rsquo;t compile until you fix them. Pain Points? I\u0026rsquo;m not going to lie, there are some pain points with Go, but they\u0026rsquo;re not as bad as you might think.\nFirst, concurrency is not the same as parallelism, but that keeps the onus on the developer to truly understand optimization for the language.\nGo also handles errors differently than other languages in that error handling is generally part of a return statement and you do need to import the errors package to effectively communicate related program statuses. The rebuttal to this is that it\u0026rsquo;s truly explicit, and the developer isn\u0026rsquo;t even tempted to write a catch all error when they can\u0026rsquo;t find the bug to prevent a fatal crash (looking at you JS).\nAnother difficulty is that coming from a language like PHP, you\u0026rsquo;re used to having a lot of tools at your disposal, and Go is a bit more bare bones, but to be frank, I feel that better tooling is preferable to more tools. You just may end up writing something that exists in many other languages.\nLastly, and one that trips me up specifically is that I\u0026rsquo;ve only ever worked with scripting languages, and Go is compiled. One must think differently about how the application is entered and how it returns.\nWell\u0026hellip; What\u0026rsquo;s the Plan? I want to be a better developer, and I want to be able to help others become better developers. I want to leverage my skills working with dozens of businesses of various sizes and industries to help define and implement processes that make developers happier, and I want to do it with Go as my primary tool. So as you can imagine, from here you can expect to see a lot of Go related content, but it won\u0026rsquo;t be the only tool I\u0026rsquo;m writing about or learning. I hope you\u0026rsquo;ll stick around and learn with me, and I hope that you\u0026rsquo;ll find the content useful.\n","permalink":"https://www.tannerlegasse.com/posts/choosing-a-new-path/","summary":"I\u0026rsquo;ve been an e-commerce developer for most of my career, and I\u0026rsquo;ve been using PHP and JS for most of that time, but it\u0026rsquo;s time for a change.","title":"Go, and Why I'm Learning It"}]