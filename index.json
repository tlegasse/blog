[{"categories":null,"contents":"Grep Usage Patterns: Mastering Text Processing for Backend Development Core Pattern Categories Basic Pattern Matching Literal string searches Case sensitivity controls Word boundary matching Line-based vs character-based matching Regular Expression Fundamentals Character classes and ranges Quantifiers and repetition Anchoring patterns Grouping and capturing Advanced Regex Constructs Lookahead and lookbehind assertions Non-greedy matching Backreferences POSIX vs PCRE compatibility File and Directory Operations Single File Processing Standard input handling Output formatting options Context line control Binary file handling Multi-file and Recursive Operations Directory traversal patterns File type filtering Exclude patterns and .gitignore integration Symbolic link handling Shell Script Integration Command Substitution Patterns Exit code handling and error detection Output capture and processing Pipeline integration strategies Variable assignment from grep results Control Flow Integration Conditional execution based on matches Loop constructs with grep Error handling and validation Silent mode applications Performance Optimization Early termination strategies Memory usage considerations Fixed string vs regex performance Parallel processing with xargs Production Environment Considerations Log Analysis Patterns Structured log parsing Time-based filtering Multi-line log entry handling Performance monitoring integration System Administration Integration Process monitoring patterns Configuration file validation Deployment script integration Monitoring and alerting applications Security and Compliance Sensitive data detection patterns Audit log processing Pattern sanitization Access control considerations Debugging and Troubleshooting Pattern Development Workflow Incremental pattern building Test data preparation Validation strategies Documentation practices Common Pitfalls and Solutions Escaping and quoting issues Locale and encoding considerations Performance bottlenecks False positive/negative handling Additional Learning Related GNU Coreutils Proficiency awk for complex field processing sed for stream editing and transformation sort and uniq for data deduplication cut and paste for column manipulation Version Control Integration Git hooks and pre-commit pattern validation Repository health monitoring Code quality enforcement patterns Database and API Integration Log correlation with database queries API response pattern matching Data pipeline validation ETL process monitoring Systems Programming Foundations POSIX compliance considerations Signal handling in long-running grep processes File descriptor management Process substitution patterns ","permalink":"https://www.tannerlegasse.com/posts/grep-usage-patterns/","tags":null,"title":"Grep usage patterns"},{"categories":null,"contents":"Introduction It\u0026rsquo;s 3AM. You need a URL shortener fast. Your boss is breathing down your neck and you have no idea what to do. My new URL shortener is exactly what you need. Okay, kidding aside, this thing isn\u0026rsquo;t geared toward production environments with high throughput or anything like that. Instead, the goal was to showcase skills that I\u0026rsquo;ve picked up over the past several months in my learning journey with Go. It\u0026rsquo;s been really fun, and this project fit the bill of \u0026ldquo;complex enough to be interesting, not so complex that you program yourself into a hole\u0026rdquo;. The latter will come shortly, but for now I\u0026rsquo;m really pleased with how everything\u0026rsquo;s come out.\nNote: This code is still evolving, it may change over the next several weeks\nFeatures The URL shortener only has 2 routes for now, one capturing GET requests for the shortening process, and a dynamic path for long-ening the path again. That\u0026rsquo;s it. Really. BUT there were so many amazing things that this project exposed me to. My previous Go projects were Leetcode problems, so I was missing on a lot of the project-level learnings.\nThings learned Implementing this functionality was a treat. It exposed me to some common patterns and enabled me to learn about the ins and outs, and infrastructure of Go projects. Check out some of my favorite discoveries below.\nTesting Unit testing admittedly isn\u0026rsquo;t every agency or company\u0026rsquo;s top priority, and I have had some ground to make up. Now, in every project I embark on, I aim to provide thoroughly tested code. In this case, I was exposed to database and HTTP server mocking, test fixtures and more. I found the workflow to be intuitive and very helpful in rounding out my chosen feature set.\nHTTP Server While the batteries included approach to the Golang standard library means that it comes with a competent and simple HTTP server, it wasn\u0026rsquo;t a mistake that I chose to work with it. I wanted to ensure that my plans of picking up API related tooling experience was in focus during this project.\nChallenges Embedding: This is the big one, and seems to fly under the radar in terms of what Go developers are exposed to first. But first, what problem will the embedding pattern solve? In short, when you\u0026rsquo;re running unit tests, the execution directory, and packages compiled into the binary are different than when you\u0026rsquo;re running your program normally. You might be able to leverage relative pathing fairly easily when your code is running from the top level directory. When you\u0026rsquo;re testing though\u0026hellip; ooh momma\u0026hellip; the filesystem context changes drastically. In the code below, you can see how I\u0026rsquo;m leveraging the embed package to compile the SQL statements needed to spin up my database table directly into the binary. Now, there are many approaches to solving this problem, and embedding files can definitely be a mistake, but in this case it was just what the doctor ordered.\nFirst, import the sucker.\nimport ( ... \u0026#34;embed\u0026#34; ... ) Using the go:embed directive, we then specify a pattern to match to the local filesystem, and initialize a variable with the\n//go:embed schema.sql var schemaFS embed.FS And then we can use the embedded file just like we would with a normal file!\ncontent, err := schemaFS.ReadFile(\u0026#34;schema.sql\u0026#34;) Understanding the data flow I will admit, dependency injection is an extremely important software design pattern as it allows for a the kind of modularity that makes huge successful projects a possibility, but it can cause issues if you\u0026rsquo;re a beginner exploring new programming languages. In this case, it was a difference between technologies I\u0026rsquo;m used to programming in (JavaScript), and Go. What could that be? Call by value.\nYes, this is a n00b issue, and was the result of storing data in structs within packages, and it tripped me up relentlessly. There would be issues where my database mock wasn\u0026rsquo;t being referenced and called for pattern matching, or data wasn\u0026rsquo;t flowing the way I expected, but I got through it. In hindsight, this one seems pretty silly, bit I\u0026rsquo;m genuinely glad that it came up so prevalantly in this project, because this is just one of those things you need to develop a sort of muscle memory for.\nTechnologies Used Viper: Parses a wide range of configuration file formats. Sqlite3 driver: Helped me drive the database. Go-Sqlmock: My favorite new package. I was genuinely surprised with how intuitive and fun the workflow with go-sqlmock was, seriously! You get to spin up a mock SQL driver, pass it to a function or declare a variable with it, and it pattern matches requests, returning pre-defined results. Conclusions I encourage you to go check out the code, because it was a lot of fun to write. This project was primarily focused on the how\u0026rsquo;s, why\u0026rsquo;s, and the most basic of basics, but the next project may (or may not!) have more real world applications, so stay tuned for more ðŸ˜‰\n","permalink":"https://www.tannerlegasse.com/projects/go-url-shortener/","tags":["project"],"title":"Go URL Shortener"},{"categories":null,"contents":"","permalink":"https://www.tannerlegasse.com/archives/","tags":null,"title":"Archive"}]